#summary Documentation about the container
#labels IoC,Container,Cocoa,iPhone

=IoC Container description=

The IoC container provides dependency injection to Cocoa applications. It was created with iPhone development in mind.

It aims to provide some functionalities from [http://www.springsource.org/ Spring] and from [http://code.google.com/p/google-guice/ Guice] (in fact, we're somehow inspired by [http://code.google.com/p/roboguice/ RoboGuice]). But due to the complexity inherent to implementing a full IoC container (as the ones mentioned before), we restricted it to very basic features.

==The basics==
The container has the following characteristics:
 * The container holds definitions about objects. No object is created until somebody request it.
 * Every definition must have a name that must be unique inside the container in order to identify the object.
 * The definition can indicate that the object must be singleton (it is created and stored in a pool when the object is requested the first time). If singleton is specified as FALSE, the object will be created each time (but it can be released when no longer required). This is similar to prototype scope in Spring, an as we learned from using RoboGuice, this behavior would be preferible in many mobile development scenarios. 
 * The definition can indicate that the object must lazy. That is, when the object is requested, a proxy to such object is returned. Upon the first method call on such reference, the object is created. This is useful for avoiding creating big object graphs unnecessarily.
 * The object can be injected (this is the main goal of the framework!). It must have properties or at least setters for performing the injection. The definition allows performing the following injections:
   * References to other definitions (by name). 
   * Values
 * New factories can be implemented for object creation customization.
 * Container instantiation can be done by code and "annotations" (like Guice/Spring) or by XML (like Spring).

==Simple example==
The main class is OxICContainer, which represents (I feel you guessed it) the container. It depends on OxICWrapperFactory in order to handle classes and objects dynamically. So, instantiating it is pretty simple:
{{{
id<OxICWrapperFactory> wrapperFactory = [[OxICSimpleWrapperFactory alloc] init];
OxICContainer *newContainer = [[OxICContainer alloc] initWithWrapperFactory:wrapperFactory];
}}}

The definitions are represented by OxICObjectDefinition class. A static method allows an easy definition creation:
{{{
[newContainer addDefinition: [OxICObjectDefinition withName: @"mainView"
                                                   andClass: @"MyView"
                                               andSingleton: FALSE
                                                    andLazy: FALSE
                                              andReferences: [NSDictionary dictionaryWithObjectsAndKeys:
                                                              @"mainViewController", @"owner",
                                                              nil]
                                                  andValues: [NSDictionary dictionaryWithObjectsAndKeys:
                                                              @"This is my view", @"text",
                                                              nil]]
];
}}}

Also, classes can be "annotated" with definition metadata. In this scenario, definitions can be added using the following method:

{{{
[newContainer addDefinitionFromClassName:@"MyViewController"];
}}}

Since Objective C doesn't provide an annotation facility (like C# or Java), we used compiler directives in order to simulate them:
